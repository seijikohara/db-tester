package example.feature

import io.github.seijikohara.dbtester.api.annotation.ColumnStrategy
import io.github.seijikohara.dbtester.api.annotation.DataSet
import io.github.seijikohara.dbtester.api.annotation.DataSetSource
import io.github.seijikohara.dbtester.api.annotation.ExpectedDataSet
import io.github.seijikohara.dbtester.api.annotation.Strategy
import io.github.seijikohara.dbtester.api.config.DataSourceRegistry
import io.github.seijikohara.dbtester.kotest.extension.DatabaseTestExtension
import io.kotest.core.spec.style.AnnotationSpec
import org.h2.jdbcx.JdbcDataSource
import org.slf4j.LoggerFactory
import java.sql.SQLException
import javax.sql.DataSource

/**
 * Demonstrates annotation-based column comparison strategies using `@ColumnStrategy` with Kotest.
 *
 * This specification demonstrates how to configure column-level comparison strategies via annotations:
 * - [Strategy.IGNORE] - Skip comparison for auto-generated columns
 * - [Strategy.CASE_INSENSITIVE] - Compare strings ignoring case differences
 * - [Strategy.REGEX] - Match against regular expression pattern
 *
 * Directory structure:
 * ```
 * example/feature/ColumnStrategyAnnotationSpec/
 *   USERS.csv
 *   expected/
 *     USERS.csv
 * ```
 *
 * @see ColumnStrategy
 * @see Strategy
 */
class ColumnStrategyAnnotationSpec : AnnotationSpec() {
    companion object {
        private val logger = LoggerFactory.getLogger(ColumnStrategyAnnotationSpec::class.java)

        private fun createDataSource(): DataSource =
            JdbcDataSource().apply {
                setURL("jdbc:h2:mem:ColumnStrategyAnnotationSpec;DB_CLOSE_DELAY=-1")
                user = "sa"
                password = ""
            }

        private fun executeScript(
            dataSource: DataSource,
            scriptPath: String,
        ): Unit =
            (
                ColumnStrategyAnnotationSpec::class.java.classLoader.getResource(scriptPath)
                    ?: throw IllegalStateException("Script not found: $scriptPath")
            ).readText()
                .split(";")
                .map { it.trim() }
                .filter { it.isNotEmpty() }
                .let { statements ->
                    dataSource.connection.use { connection ->
                        connection.createStatement().use { statement ->
                            statements.forEach { sql ->
                                runCatching { statement.execute(sql) }
                                    .onFailure { e ->
                                        throw RuntimeException("Failed to execute SQL: $sql", e as? SQLException ?: e)
                                    }
                            }
                        }
                    }
                }
    }

    private val registry = DataSourceRegistry()
    private lateinit var dataSource: DataSource

    init {
        extensions(DatabaseTestExtension(registryProvider = { registry }))
    }

    /**
     * Sets up H2 in-memory database connection and schema.
     */
    @BeforeAll
    fun setupDatabase(): Unit =
        logger.info("Setting up H2 in-memory database for ColumnStrategyAnnotationSpec").also {
            dataSource = createDataSource()
            registry.registerDefault(dataSource)
            executeScript(dataSource, "ddl/feature/ColumnStrategyAnnotationSpec.sql")
            logger.info("Database setup completed")
        }

    /**
     * Executes a SQL statement against the test database.
     */
    private fun executeSql(sql: String): Unit =
        dataSource.connection.use { connection ->
            connection.createStatement().use { statement ->
                statement.executeUpdate(sql)
            }
        }

    // ==================== IGNORE Strategy Tests ====================

    /**
     * Demonstrates using IGNORE strategy for auto-generated timestamp columns.
     *
     * The CREATED_AT column is auto-generated by the database and cannot be predicted in test
     * data. Using [Strategy.IGNORE] skips comparison for this column.
     */
    @Test
    @DataSet
    @ExpectedDataSet(
        sources = [
            DataSetSource(
                columnStrategies = [
                    ColumnStrategy(name = "CREATED_AT", strategy = Strategy.IGNORE),
                ],
            ),
        ],
    )
    fun `IGNORE strategy should skip auto-generated timestamp column`() {
        logger.info("Testing IGNORE strategy for CREATED_AT column")

        executeSql(
            """
            INSERT INTO USERS (ID, NAME, EMAIL, CREATED_AT)
            VALUES (2, 'Bob', 'bob@example.com', CURRENT_TIMESTAMP)
            """.trimIndent(),
        )

        logger.info("IGNORE strategy test completed")
    }

    // ==================== CASE_INSENSITIVE Strategy Tests ====================

    /**
     * Demonstrates using CASE_INSENSITIVE strategy for email comparison.
     *
     * Email addresses are often normalized to lowercase by the application. Using
     * [Strategy.CASE_INSENSITIVE] allows comparing expected values regardless of case.
     */
    @Test
    @DataSet
    @ExpectedDataSet(
        sources = [
            DataSetSource(
                columnStrategies = [
                    ColumnStrategy(name = "EMAIL", strategy = Strategy.CASE_INSENSITIVE),
                    ColumnStrategy(name = "CREATED_AT", strategy = Strategy.IGNORE),
                ],
            ),
        ],
    )
    fun `CASE_INSENSITIVE strategy should compare email ignoring case`() {
        logger.info("Testing CASE_INSENSITIVE strategy for EMAIL column")

        executeSql(
            """
            INSERT INTO USERS (ID, NAME, EMAIL, CREATED_AT)
            VALUES (2, 'Charlie', 'charlie@example.com', CURRENT_TIMESTAMP)
            """.trimIndent(),
        )

        logger.info("CASE_INSENSITIVE strategy test completed")
    }

    // ==================== REGEX Strategy Tests ====================

    /**
     * Demonstrates using REGEX strategy for UUID validation.
     *
     * UUIDs are auto-generated and cannot be predicted. Using [Strategy.REGEX] with a UUID
     * pattern validates the format without requiring exact value match.
     */
    @Test
    @DataSet
    @ExpectedDataSet(
        sources = [
            DataSetSource(
                columnStrategies = [
                    ColumnStrategy(
                        name = "TOKEN",
                        strategy = Strategy.REGEX,
                        pattern = "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}",
                    ),
                    ColumnStrategy(name = "CREATED_AT", strategy = Strategy.IGNORE),
                ],
            ),
        ],
    )
    fun `REGEX strategy should validate UUID format using pattern`() {
        logger.info("Testing REGEX strategy for TOKEN column")

        executeSql(
            """
            INSERT INTO USERS (ID, NAME, EMAIL, TOKEN, CREATED_AT)
            VALUES (2, 'Diana', 'diana@example.com', RANDOM_UUID(), CURRENT_TIMESTAMP)
            """.trimIndent(),
        )

        logger.info("REGEX strategy test completed")
    }

    // ==================== Multiple Strategies Tests ====================

    /**
     * Demonstrates combining multiple column strategies in a single test.
     *
     * Real-world scenarios often require different comparison strategies for different columns.
     * This test shows how to combine IGNORE, CASE_INSENSITIVE, and REGEX strategies.
     */
    @Test
    @DataSet
    @ExpectedDataSet(
        sources = [
            DataSetSource(
                columnStrategies = [
                    ColumnStrategy(name = "CREATED_AT", strategy = Strategy.IGNORE),
                    ColumnStrategy(name = "EMAIL", strategy = Strategy.CASE_INSENSITIVE),
                    ColumnStrategy(
                        name = "TOKEN",
                        strategy = Strategy.REGEX,
                        pattern = "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}",
                    ),
                ],
            ),
        ],
    )
    fun `multiple column strategies should be applied correctly`() {
        logger.info("Testing multiple column strategies")

        executeSql(
            """
            INSERT INTO USERS (ID, NAME, EMAIL, TOKEN, CREATED_AT)
            VALUES (2, 'Eve', 'eve@example.com', RANDOM_UUID(), CURRENT_TIMESTAMP)
            """.trimIndent(),
        )

        logger.info("Multiple strategies test completed")
    }
}
